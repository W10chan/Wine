# -*- coding: utf-8 -*-
"""PyT_WINE3ray.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oiEij7-ZhIKxIYcxSoOKdJLFQN3xGOeF

# **ニューラルネットワークを使ってワインの種類を分類**

**大まかな流れ**

1.   13個の特徴量(input layer)を持つワインのデータセットを用意
2.   隠れ層(hidden layer)を通して、出力(output layer)を計算
3.   出力値と正解値から誤差を計算
4.   誤差を逆伝搬し、重み(パラメータ)を更新
5.   処理を繰り返し最適解(モデル)を探す
"""

'''ライブラリの準備'''
import torch
import torch.nn as nn #ニューラルネットワーク関数
import torch.nn.functional as F #活性化関数
import torch.optim as optim #最適化関数（目的関数）
from torch.utils.data import DataLoader, TensorDataset#データローダ、でーたせっと
import pandas as pd
'''データセットの準備'''
from sklearn.datasets import load_wine#ワインのデータセット
from sklearn.model_selection import train_test_split#データセットから教師データ・テストデータを分離

"""**学習に必要なライブラリとデータセットを読み込み**"""

'''データの読み込み'''
wine = load_wine()#ワインデータの読み込み(データセットをwineという名前で登録)
wine

"""**今回利用するデータセットの中身を確認**

"""

#先ほど取り込んだワインデータをデータフレーム型(DataFrame)に変更
wine_df = pd.DataFrame(wine.data, columns=wine.feature_names)
wine_df #ワインの特徴が入ったデータ

"""*加工や抽出などデータ解析に必要な操作ができるのでとても便利*

wine.dataでwineというデータセットの「data」を参照し、カラム名(列名)には「feature_names」をセットしました。

**targetデータを「class」という列名でデータフレーム型に変換**
"""

wine_class = pd.DataFrame(wine.target, columns=['class'])
wine_class

"""先ほど作成したwine_df（ワインの特徴が入ったデータ）とwine_class（ワインの種類：0 or 1）を結合するために、DataFrame型に変換しました。

**学習データの準備**
"""

'''学習データの準備'''
wine_cat = pd.concat([wine_df, wine_class], axis=1)#データの結合
wine_cat.drop(wine_cat[wine_cat['class'] == 2].index, inplace=True)#「class」列で値が「2」の行を削除
wine_data = wine_cat.values[:,:13]#wine_catの1~12列の全行を取得
wine_target = wine_cat.values[:,13]#wine_catの13列目の全行を取得
print(wine_cat, '\n')
print(wine_data, '\n')
print(wine_target)

"""pd.concatでデータを結合。axis=1は横方向を意味します。
.indexは行番号を示しており、dropでそのデータを削除することができます。
また、inplace=Trueで結果をそのままwine_catに代入しました。
.valuesを使うとDataFrameの値を配列として取得でき、wine_data.values[行, 列]で任意の行・列を参照します。

**データセットの準備とPyTorch tensorへ変換(型変換)**
"""

'''データセットの分割'''
Train_X, Test_X, Train_Y, Test_Y = train_test_split(wine_data, wine_target, test_size=0.25)
#全データの75%を学習用、25%をテスト用に分割
'''PyTorch tensorへ変換(型指定)'''
train_X = torch.FloatTensor(Train_X)
train_Y = torch.LongTensor(Train_Y)
test_X = torch.FloatTensor(Test_X)
test_Y = torch.LongTensor(Test_Y)
train = TensorDataset(train_X, train_Y)

"""tensor型に変換できたらTensorDatasetを使って、train_Xとtrain_Yを一つにしたtensor型データセットを作成

**DataLoader：データセット(train)からサンプルを取得してミニバッチを作成**
"""

train_loader = DataLoader(train, batch_size=8, shuffle=True)#8個のデータをまとめて学習

"""**モデルの定義**"""

'''モデルの定義'''
class Net(nn.Module):             #PyTorchでクラスを作成するときnn.Moduleを継承
  def __init__(self):
    super(Net, self).__init__()
    self.fc1 = nn.Linear(13, 128) #入力13,出力128の全結合層（入力層・中間層）
    self.fc2 = nn.Linear(128, 2)  #入力128,出力2の全結合層(中間層・出力層)
  def forward(self, x):           # 順伝搬
    x = F.relu(self.fc1(x))       #活性化関数ReLUを選択
    x = self.fc2(x)               #その結果をfc2に投入
    return x                      #最終結果を出力
net = Net()                       #このnetにデータを入れる

'''最適化手法の定義'''
criterion = nn.CrossEntropyLoss()               #交差エントロピーで評価・・・SGD(確率的勾配降下法)との相性
optimizer = optim.SGD(net.parameters(), lr=0.01)#optimizerにSGDを指定(lrは学習率)

"""**＜クラス作成時の公式＞**"""

#PyTorchでクラスを作成するときの公式
class MODEL_NAME(nn.Module):
  def__init__(self):
  # ここで「結合層（入力層・隠れ層・出力層）に関する記述」を書く
  def forward(self, x):
  #ここで「モデルに値を渡したときに呼び出されるメソッド」を書く
  return result

"""結合層（入力層・隠れ層・出力層）のイメージ

![input_output.jpg](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMSEhUTEhMWFhUWGB0YGBcYGB8YHhkXHRgbFh0XGRkdHSggGh4lGxkYITEhJSkrLi4uGR8zODMtNygtLisBCgoKDg0OGxAQGy8mHyUuLS0rLS0tLS0tLS0tLTAtLS0tLS0rLS0tLS0tLS0rMS0tNS0tLS0tLy0tNystLTItL//AABEIAJ0BQQMBIgACEQEDEQH/xAAbAAACAwEBAQAAAAAAAAAAAAAABQMEBgIBB//EAEMQAAIBAgMFBAcHAwMDAwUAAAECAwARBBIhBRMxQVEiMmFxBhQVUmKBkSMzQlNykqGCsdFDY6IkwfAHNHMWg6Oywv/EABgBAAMBAQAAAAAAAAAAAAAAAAACAwEE/8QAKxEAAgIBAwIFAwUBAAAAAAAAAAECEQMSITFBUQQTMtHwobHBYXGBkeEU/9oADAMBAAIRAxEAPwD7jRRRQAUUUUAFFFFABRRRQAUUUUAFUsXjSjWtfTrV2lG1O/8AKnxpN0xZukSe0z7o+tHtM+6PrSTaW0FhUFgzMzBURBmd3PBVXmed+AAJJAF6ItnbQkGa+HgB4IVaZrfEQyKD4C/marKOOPIicmO/aZ90fWj2mfdH1rP4tsVhhmxCJLEO9LAGBQe88LXOUcyrHyq9FIGAZSCpFwQbgg8CDWxhB8GNyQ6weKz30tardLNk8W+X/emdRmkpUikXaCiiikGCiiigDl2sCegpd7TPuj60wn7reR/tWfFWxRUuRJtoYe0z7o+tHtM+6PrWeONllkaLCRiRkNpJHYrFGealgCXcccqjTmRerPsfaA13+FY+7unUeWfeEjzsfKtaxpirWxx7TPuj60e0z7o+tIMLtBt5uJ4zDOBmC3zK682iewzgcxYEXFwLir9OscHujHKSNDG1wD1rqo4O6PIf2qSuUsgooooAKKKKACiiigAooooAKKKKACiiigDiWTKCelU/ag901ZxncbypFSydF8UFJbjT2oPdNHtQe6azc+1e2YoY3nlW2ZI7WS/vuxCJ1sTe3KvXlxii74Fiv+3MjsB1ynLfyBJrLYzjjTpmj9qD3TR7THumkWAx8cylozexysCCrKw4qynVT4GrNZqY3lRNEK9rwV7VDkCiuJZVUXYgAcybD60vO3I20iDzH/bW4/ebJ/NADOku1ZAJLEgGw51MZMU/ARwjqx3jW8hZR9TXz70wwbYiRGid5mykZjYBwNTuwAOyOF+ZIteng6YslaNV6MwibFYidhfckYeLwGRJZGHixdVv/t1q6xPoIvqskmEc6yBZ478+wkcqj9LKDbpIK21ZK73NjwBFYfBhMNPiMNcLGhWWIE2ypKCSgvyEivYDgCBW3Jr5ptbA+vST4uPXKwSDo6RghiP1OXseYUcjTY7vYyVUbLZWNiBa8icvxDx8aY+0IfzY/wB4/wA1jfRt8wNoopSACUZVV7ai6NbK48wLcDrWiwr4R2yGJEk/LeMK3yuLN5gkVk3cgiqQw9oQ/mx/vH+aPaEP5sf7x/mufZsP5Mf7F/xR7Mh/Jj/Yv+KQY69oQ/mx/vH+aPaEP5sf7x/mufZkP5Mf7F/xVbGphIgN4kS34DICT4KoFz8qALE+0Isrfax8D+MdPOsZj9vRth5Gw8imS2VAeIdiEUleOjMDTbaJXdlhh4oU4B5IwXYnQBIl1ueVyPKvnmD9HJXLsqmyKXiJPekQhkUkfELHlxqkJNcCyS6n1/Y2zUw0KQxjsoLX5sebsebMbknmSau1T2PtFMRCk0Z7Li9uYPNSORBuCORFXKmMIPTbA58K8ife4f7aJuYZBcrfkGXMh8GNQRSBlDDgwBHkRep/TbG7vCvGp+1n+xiXmXcEE26KuZz4KaUphWw4G6u8YFjGTqLc0J//AFPytV8N7k8hsYO6PIf2qSquzcWksasjXHDyI4gjiCOhq1UCiCiiigAooooAKKKKACiiigAooooAKKKKAIcb3G8qye28Q6RWi+8kdYoz0aRgma3PKCWt8NazG9xvKsft+TIsUx7sM8cj+CXyO3kquW/ppJcl8XoZqNjbMjw0SxRCyjiTqWY6s7HmzG5JPWr1eKb6ivacgZX0twghdMagswZI57f6kTNkBPijsGB6Zhzr3EYyOPvuq+BOp8hxNTenkoOF3IPbxDpEg5m7BmI/TGrt/TWT2fC+Gdkdyttd4FVgVJ0ZgRmtyJB05240skXxSaRuxtR3+5gdh7z/AGS/8u1/xo9VxL9+YRj3Yluf3vf+FFeRvigAV3EqngQWjuOo7wNde1HX7zDyjxUCQf8AE5v4piB1FsSEHMymRvekJkPyzEgfK1WsXikiQs5CqP8AwADmfAUsxXpNAosGvIdFjIKMSeue2UeJ0qTC4W5387qzKLix7EQ55eptxc6+Q0oAqY52dDJiFKw6BYB3pWJsoe3U2sg/q6CJcIyMXktvHAzW4KBwjXwUfU3NX8BGZ3GIcEKPuVPIHQyEe8w4dB5mjanf+VUxeoSfAp2jgFmUBiyspzI6mzI44Mp/7HQgkEEGvE2ltCIWyYfE/Gzth2t8QEcik+Vh4Co8XPI8q4bD23rLnd2F1ijvbORzYnRV52J4A0wg9DcNb7YPiH5vK5a56hAQi+SqKpkcb3MimLcYuKxQy4h0iiPeihJJce60xAIXwVQT1tpV+KMKAqgAAWAGgAGgAFcYz0WMQL4F2jYa7p3Z4n+EhrmP9SWt0PCotmY4TR58pUglXRuKOpysh8iOPMWPA1uNx6CzT6kcmEVGMmqoSCXXjDIdBKvwngw4czzpykok/wCnxaKXPdJHYkA/Enut1XiOVxrXWz8tnz2y21vwtre9J1xakeqqhnQn7CS+VRbXLvT+JORW5t5Go5PUykOBz7Pli+4luo/05buPJX76/PMPCqsnpTHGSkyMsgt2Vs410HbHZX+vLVdY5Qyx42VihsFKHIjN7sjCzZvoD56VoMPhI0XIiKq+6BYfTnSDFBVxE2pYQIeSWdyP1nsr8gfOvHSHC6ohaV9FF80kh/UxvbqSbCqmPw6xMEwhZJm13a/d296RToq+IsTyqtJiZcKSZI97PLcLKt2Fh1jtmRFBvYXv1uaAOp8M8shV2vJlvIy92CMj7qP43HFuNrnTQVJGgUAAWAFgByHSmOyljEJ3biS9yz3uWc8S3Q+HLhS9mAFybAak9BXRh6kshQ9SlikaXCSCMubyROuaORvesCCj8synXmDU3tnaB7Pq2GX49+7/AD3e5B+Waodl7Pkxw3sjvFhm+6jQ5HlTlLI47Sq3EItjaxJ1sGZ9DMFbSHKfeV3Vv3hs380kpQvgZKQswmzm3m/nk309soa2VUU6lIkucgNhc3JNhcmwphS7FRS4J0Ekhlw8jBFke2eJybKkhFg6sbKG4g2Bve9MavBprYnJO9y9Ls4m0sLZJbC54q4t3XHP9Q1H8VNgNohyY3XdyqLlCeXvIfxL4j52q3B3R5D+1Q4/ApKAGvcG6sDZlPVTyNcZdFqilMWOeEhMRaxNlmAsrdA4/A38HlbhTagAorxjYXqr68OhrG6Mst0VU9eHQ0evDoazUgtFuiqnrw6Gj15eho1ILRborxTcXr2mNCiiigCHG9xvKkDoGBBAIIsQeBB0INP8b3G8qQswAJJsALknkOtJI6cHDF+AxWIwQyLGcThx3AGAmjHJBmISRANBdgwsBrxq8/pYx0jwWKLfEEjUfqYvw/SGqlgIsRjBnjf1fDnuvlDSSjk6BuyiHkSCTxsKuN6LSAXjx0+b/cEbqT4qEU28iK1WTl5dlTD4aV5fWMUymWxVES5SFTxCEi7MdLubXsLACpsbhc4BByuuqN0PQ9VPAiocNipFk9XxKqstiysvclQaFkvqCLi6nUXGpGtXyQNToBzpXdnRHTp2PcArAFsOAjqbS4Zj2c3G6H8F+IPA31FTDbZmJiw62lHfziwh5doA9o9AND1FVMckmIO9wwKqq2L3ymdeJROg42c8+GhvVrc4VoUdWEIXuuCEZD+IEnib8Va9zxqhxF/CbMRAc32jN33exLf4HRRoKTybIgxEpVIwkSEiRk7G8f3BlsCBxJ62HI1SxfpO9jAvbclRv4xlXI1xmu9grm1hqRc3vyp1hMNiAiom6gQCwAvK3nc2W/jrQBL7NkX7vEyDwfLIP5Ab/lWJ9KfSSaDEIM8MoC9rILA68D2jlYW6861uOwcMYBnaSZibKjNfOeixLZT9NOdJ9p7BEzKZ1VMtikcdgEF7lWIHaJtry6daeCbewsqrcn/9P5xN61OQQzzBbHiqLDGVXy7TN/XWurFw4wYLENI2mGny7xuUUqjIrt0RkAUtyKLfQ6bJHBAINwdQRwI6ismmnubF2jqvnO39pnC47EKi3EoicnkjlWQk8BdlReY4GtztfasWGjMkzZVGgHEs3JUUasx4ACstgMK0gllxCWfENnZDrkQAKkd+qqATb8Ra1NjTb2Mk1W51shd5d3hlxHAi7RlB5IHy/W5pxjpGlTIcLMOakGIFWHBl+00INJsHhBCxzM6KbZZ0NrHksw7rdAxHnY6nQesYiL7xBMvvxaNbqYydf6T8qyfqCPBSw21HkVoZsK7OoAkW8dmB4MAX4H+DccqWybcngzxJFIyJbtuVYw3PByHs1hqLkEDjprVrG4v1tr4Ju3EDmkvlJBGsIBF7nQ5iLKQOdOtkbowjdCya3B4hvxB78Wve9+dIMLIcaMNGXOHmN7FpC0bM7HQcJNSbgADwArrASzBmlkw0pkfTRo7Ig4It3+Z6nyFUFIjPrFr4NGJRCeB4GZAeK3vZfMjkKcx7WaYXw0edT/qv2E+X4m+Qt40AUtopmDP6pMjgH7RGjVuHMiTtDwN6+aw7eleOSCQl1mIUnmqu6q/9OVj5Xr6PtCFnJjZzPLa5TuQxj3nUG7eCsST4DWk8fovEEmW5vMhQtoMt+aAd3Wx8LCqQi3wLJpcm9jQAAAWA0A6AV1SD0Y23vV3ExC4qMWkThnA030Y5o3Hw4HUU/qfAwo9LsOsmCxKtoN05v0IUsGHQggG/hSHDbWBRTIsiEqCSyG1yL94XFWfSvaAxF8DCcxewxDDhFFxKE++47IHEAk8hezV8KfJObQ42fjY5FGSRG0HdYH+1W6oNsyGRQXiRjYa5Rfh141F7Hy/dTTJ4Z84+j5v4tUCiGMsYYFWAIIsQRcEdCKVbuTC6oGlg5pxeP9Hvr8PEcr8Kly4tODQyjxBjP1GYfwKPajr97h5V8VtIP+Jzf8aALcWJSSPOjBlINiKW1WmxEJZnw0yJIe9G5yiT9SGxVviA870li9LomjnZVOaJbhSR2zwABHxkD5ikmhJIa7Q2tHCwQ5mkbVYo1Luw4XCjULf8RsB1qudqzjVtn4sL1G5YgdSizFj5AE+FOPRzY3q8d3IeeSzTSc2foOiLwVeQ+dOKFBG6TN7P2jHOpaNr2NmBBVlb3XU9pT4EVaqj6X4MQj1+MWkhF5bf6sA7yt7xUEup4gi3AmroNLJUK1Q5i4DyrquYuA8q6qpQKKKKAIcb3G8qx23494sUJ7s80cT+KE5nX+pVZf6q2ON7jeVZLbkDtEGi1kidJkHvNGwbJrwzC63+KkfJfF6HRsUUAWAsBXVUtkbTjxMSyxG6sPIqeasOKsDoQdQRV2nIGb9O4gMNvx38O6SqegDBXHzjZ1+dZuDaRxTXCqUB7MbSKoPxOBdm/Ta3nT/0vxYlZMEhuzssk1vwQowftdC7KFA5jMeRqlitlC5aNUN9WjYXVvL3D4jTqKWRfGnX6GhXBTv95PlHuxKF+Wdrn6WpTtbBR4NhPGgkZrqUcl2ZrFt4rG5BFu14eQqaFMMFZgZMO0Yu6B2Ur5JcqwPIgEGusBs7Ek79pu2QQqyoGyRk3AJUrZjpc+Q5UxAZbLwaiK5IkMvad+Ickch7ttAOlLMTLJhn3eFBm0uYCfuhyYOeA6IePK1KvX8TFnWJV3DOAZYzpGxJzbvPYWJtrqqk8eQfYLGxQLlMU0fMlkL3PNmdcwJ8SaAJNhxxteXPvJTo7MMpX4Ah+7A6c+JvRtTv/KuJdxO28gnVZhpmUgkj3XS/aHgeHK1K9q7aETqmJGRzYAjVWHDMDyHUHUePGqYnUhZrYtMBY34c78LeNZiFsLdhhGxdufqm+MV762ygxA345dabLghjcQ0L64aEDer+bKwzLG3wKtmZfxZlB0uDs40CgBQAALADQAdAOVPkyK6FjE+f7J9UM2hkOIsf/c7zegc8gm1C/o0p/TXa+yYsTHu5VuOIPBkbkyMNVYdRWX2fi2QSx4hhnw7ZHc6Z1IDJJbqykXA/ECBTY5p7GSjW5oNnAWfNbLbW/C2t7+FJrvY5M/qN9SO/l55Pxbm/PjbhpUWExazMQyu6i1oEFyx5NMeCDopI8elP9xiJe+whX3Y+01vFyLD+kfOo5PUx4cEOPGDCJmyjQbrd3z25bvJ2vpWUx5xN591vNx2d9ny5/HhpfJbNfW1r07xmD9Ta2DW7yg5o7ZmAA1mBOumnZJsxItY072OsQhG6OZdSSeJY94vf8V73vSDC3ZYwxdd5m31uyJ+P/wBsfd2/RUWM3gkf1G/+9a2UN/t303tr+Hva1VAEhGGv/wBI7EJIRe5GphQngONn6AgcAadRbJaEAYaTKo/0n7addD3l+pHhQBJsoRbg7nhrmvfNn55765r8b0vqPHzshMjIYJbWYntRSjozgdk9GIBHiNKUR+k0JSZtbwoXZeJNuIW3e1sNONxV8LSsnNE+3xhcqnFZRr2Dch81v9Ip2836daWO8WX7Rtp7r4hiQtvEgZ7efzrVejGxN2N/OA2KkF3bjuwddzGeSLw8TqeNaCllkt8GqNGQ2QIN0vq2Tdct3ax68Od+N9auVV9KdnjDXx0Iy5bHEoOEsXAyEe+g7V+JAIN9LWifpVoT1InKND+DujyH9qkpWu2oQAqsZGsOzGDIfnl0HzIo9YxL9yJYh70jZj+xNPq1chdDSqWL2rDEbO4ze6O0x8lW5P0qD2SX++mkk+EHdr9EsT8yamKQYVCwVY1HGwtc9NNWJ6caAKG0MS0yMBhuxlPbnIQAW4hbFtPECvlOC2PJaSWxy4fLKdD2wrq9h1BVSfpX1o4Z8R25xljGqwnn0aXqeYXgOdzw8IpZOhW6G8UoZQym4YAgjmCLg13WPwDzYH7NIzPhfwKpAkgHuKpsJIxrbXMNBYjhd/8ArGE6LFimb3fVpV+WZlCDzzWrU0baLPpniBHgcQbXJjZFX3ncbtFHmzAfOo8PHlRV91QPoLUv3U2JlSXEKI44zmigBzHPa28lYaFgCbKLgXJuTazSpydiSY4i4DyrquYuA8q6qpQKKKKAIcb3G8qRU9xvcbyrM7RxiwxNIwJCjgOLHgFHiSQB50kuTpwcMq4nACNmnimbDOdXZSuR7C15EcZSbAdrRrC16qQbcec7tdq4cnpAsYf5Eu4HyWnWyPRgNabHBZpjYhG7UcPRI0OlxzkIzE9BYB1i9kwSrkkhjdfdZFI/kVqTElOLfBn8Bs9IQQgN2OZ2YlmduGZ2OrHzq1S7EYNsDKihmbCzNkXMSzQSG5CZjqY24C+qmw4EWh2tjgW3K3JPfC94jjkXxPM8h5ilaLRmnHYa42OPEnfSNkhh+7kFgWe/fB90EWA/EeulQ+syvlGLzJhzwa2Xea6b/X7IEctAeZHdq9HAiZZMW8a5fu47gJHyGUHvN8X0tVh9qiQERQySg6XK5EPmXtceQNUOMYblCmTKuQrbLbTLa1rcLWpbg5TA4hkPYP3Lk8hrumPvAcDzA6g1QGAxkYJiZUS99ypzlRz3TuAFPDskZelqmg2XhsSjZmklbg28Y5kb9HBGHgKAJsbjcLJpkE56JHvbeZAsvzIrEelOwJZp491CYkK2szXy68SASFvfgDyre7JxBUmCQASINCBYSJwDqP4I5HwIrjanf+VPCOp0xZOkKP8A0/h3XrULEl1mDFjxZWhjCt5dkr/RWurG4uGSOVcTh7GQLkeNjYSxXvlvydTcqx6kcDTCH0zwtvtnOHbmk6lCD0zd1vNSRRODTCMrRoq+c+kGzWxOOxDRsAIhCjC5s7hWex46qrryPGn2N9K94MmBQyudN6ylYU+JmNs/6UvfwGtQ7MwIhTLmLsSWd24u7G7MfM8uQAA0FNjhb3MnKiHY77u6PM+H4AApGEJ8Hy5f7GnOOSSJC5xUh5KAkZLMdAq9nUk1Ls8LZ89sttb8La8b8qTrhFH/AFSuYY1P2MZBZTfTPuzwL8AFsbeZpciqRseC7htmSxq002KKuygyHKllA/CCV0A1+dzzpXJsbET7ySOVwj27DKqGex1LALZbjQXFzz0q6JpWZXxsTLGLFVQZ0De9KBdsw5AgqOt60UGJR1zo6svvAgj60gwihwXrMRT1iQAWDIUjVo2GoFgvZIsCCPAiusAs5ZopMS4kToiWdD3XW6/I9Dfwo2hiFkfNhMzzLpnT7sj3JWNlYeRJHKqkmHlxROdxFPFfLEt10PvSXzOjAcVsB5igCztKQoGT1uR3IP2aRo7cOahdB4mwr5nBsKZI5J5AUSEhmB4sqOrOP05VOvhX1vZRiMJMUYj4hltYq44hup8efGl7KCCCLgixB5g6WquOCkJKVGijcEAjUHUHwrqsZsraUmBG5lV5MMukUqKXaJOUcqDtELwDqDpYEaXLQ+meB5YhWPuqGZ/LIBmv8qm4tDJpln0tnVMFiWbUblxbqSpUADmSSBbxpBhdkrkUSlpCFAIdri4Hu93+K9xc8mOdC8bRYaNg4jcduZwbqzr+BFNmC8SQCbWsWNXxQpWyc5D3CRhUUKABYaAWHCpqjg7o8h/aqmP2hlbdxDPKRcLyUe+5/Cv8nlXOVRJtDHrEBe7M2iIurMegH9zwHOq+EwDMwlnILjuINVj/AE9WtxY/KwqTZ+zshLuc8rd5z091B+FR0+tzV+gDmQaHypZ6s3u01orHGzGrFXqze7Xvqz9DTSil0IzShV6s/Sj1Z/dprRRoQaUcxjQeVdUUU4wUUUUAQ43uN5Vj9tWvhs3d9ahzX/USv/5MnztWwxvcbyrMbTwQmiaMkjMNGHFWBzK48VYA/KklydGJXFo1gr2s5sT0lUkQYoiLEjTXRJeWeJjoQeOW+ZeB5EvMTjI41LyOqKNSzMAPqac56oS+nwHqMvW8eT/5N8mT/nlrLbP2XNFcyCRixuzRMt21vqTZ/kKbYvHHHSIUBGFibOGItv5BcKVB13antZvxG1tBqxpJM6MUNrZ3hMTg4jcqY296VGB+cjjX607w+JSQXR1YdVIP9qkFUsRseBzdokJ961j+4a05zl6qOO2aHIdSY5RwkXj5MODL4H+Ki9kZfuppo/DPvB9JA1AixS8JIpB0ZCh/cpI/40AUsXIWyxzWimBvDMNUZvA8rjQo3EcL8a4OM3hIZcsiWDpxs3UHmpGoNXMRiJGUpNhCynQ5GWQH5NlP8VgvS3aZgkUQtIDlIG8UhkX3LsO2L6gm5FuNPCWl2LJWjT7R2gkKgtclmCoii7O54Io5n+AASbAVzHs/aEov/wBPh+iuGna3xFWRQfAFvM1F6DuMXJJi2H3YEEfw3RZJWHizMF8k8a2lPPK72FjBdTGYyTE4UZsTGkkQ700N+wPeeJrnL4qWt0trV6NwwDKQQRcEagg6gitIRXzTaeN9RkmwkYOrB4OJCRyAswHHRXD2HIFRwFbDL3CUOw7kxauxjNygIDIvemfiIl8BxY8OR505SEJ/1GKZQw7ov2IgeS37zdW49LCs96NQMoOV44zYAyOQz2uTZEvZRfW5JJOpFaLDYXDK2dpFkk9+Rwx/p5L/AEgVObuQ0eDr2jJJ/wC3iNvzJLovmF77fQDxqpJ6LJIS0rsZGtcoAi6a/di4b+vNTn12P8xP3D/NHrsf5ifuH+aQYoI88IAZBMg5xgIwHjGTY/0keVeO0OK7j5ZY9QQMrxnxVtbHmCLGmHrsf5ifuH+aqY2PDS23hjJHBswDL+lgbj5GgBRNinikLOtpMv2qr3ZkA++j+JRxXjbTWwNSo4IBBuCLgjmOtc7ShO7I3yTINQsjhXUjgUlXmPEfOvnWD9JZULqrGzKUiBA7MjkBGIHxG5HDjVcc1HkScbNwcdJLI0WFjEjIbSSM2WOM+6zWJZ7G+VRpzI0qf2RtAdrfYVvg3Tr8t5vD9ctP9jbNTDQpCg0QWvzZuLOx5sxuSepq7WPLJmqCRjcLtAmQwTRmGcDNkJzB14F4nGjgG1+BFxcC4q/Unptgs+FaVB9th/tom5hkFyt+jrmQ+DGlC4hsQBuyUiIuX4FvhToOrfTrVceS1uTlGh82NeT7LD2zAAPIdVj04Afifw5c+hvYDArEpC3JJuzHVmb3mPM11gIFSNVQBVAFgKsVzFkFV8bjEiXM5sLgCwJJJ4AAAknwFWKXbXwTSbtoyM8T51DcD2SpBtw0Y69bVjutjGdYfa0UhUK2r5gBYg3W2YEEdki40Nqpt6SRB7drJumkL5WsAjZSOHgf/DVddjzrIJwYzKZGZlNwtmRY7BrXuAgN7a68Ko4zYs0UDaq5GHlRrA3JZjICg566WqTlKhbY+i27A2oc8UFirA9s5UIBFypOl+FcY3biI6IAWJlETWDdklM/Ia6W+vhVCbY88v2jmMSBYwgF8pySCW7E6jMQBbW3jXS7InLGRjHn36y5QTbKIt0Vva99b3tr4U1yC5DHGbTEUqq9gm7eRmJ4ZCo//r+K8i25C2mZgcyrZkZSC98twwGhsQDwqHbGzJZWzRuEIidAeYZmQg+VlI+dKMRslokxDyD7yNFVUMkzCRGZlN21PaKm+gFvnWOUkwbY/n21CpILEkMVsqsxuACbBQSQARcjQV4u24S6IGLNIoZcqsbqbgMSBYC4PG1KG9HXKwN2WkVWzhmZAzSEOzBk1FmHDpTDY+yGhcMcthCsdlBHaDu5IBJ07XWtTlfAWxvmorqiqDkOM7jeVI7U6OJGcpYiwDXtpqbWv104V3vVte4tStWVhk0LgzuJwqSKUkRXU8VZQwPyNUMP6N4RGDJhYVYcCIxceWmnyrZK4PMa8KrrjkMm6BBcKHt8JNr/AFBrNP6j+bfQU2NFqbQ49GaRRoYiA19BcqGFj5EVOrg8x1o0g8zXKJBXtR74aajXh4+VCyAm1xTnOSUUUUAFItsYSNpQzIrMAACQCQPnT2lG1O/8qpi9Qk+BV6MTCHE4jDtpvSMRFyuMiRSKPFWUE/8AyCtZWR2ls9ZlAJZWU5kkQ2eNx+JT/BBuCCQQQa9h2nj4+yyYeccnzNCx6ZlyupPUgjyFNPG7tGRmq3NbWHwpTE4jEYnKGjYrFESLgpFcFxfkZGex5hQalxfreKGWd0hiPejgZizj3WmIWynmFUH4qvRRKqhVAVVFgALAAaAAcq3HjadsycuiLWysBES14o+X4B4+FMfZsP5Mf7F/xVbZPFvl/wB6Z1PJ6mPDgq+zYfyY/wBi/wCKPZsP5Mf7F/xVqikGKvs2H8mP9i/4o9mw/kx/sX/FWqKAKU+zYcrfZR8D+AdPKsZjvR+NcPIMPGu8AzITqS6EOoLHUXZQPnW9n7reR/tWfq+JJpk5uhvsjaKYiFJoz2XUHoQeasOTA3BB4EGrlYsYOWGRpcJIqFzmkicFonbm9gQUc82Gh5g1ZO2seRYYfDKfeM7sB45RECfK486R45IZTRc9Nsdu8K8a/ezjcxLzLuMt7dFXM56BTUEMQVVUcFAA8gLVSwmz23m/xEm9mtYG2VI1PFYkucoPMkljpc2AFMKtjhpW5OcrH8HdHkP7VJUcHdHkP7VJXKWQUUUUAFeWr2igAooooAK8r2igAooooAKKKKAMj6T4B5JHsjMrJANPDEhmHyW5PhVLaeBSKULuSYTikKxquhHq7Zsq8xcXIHGxrd1FNArZSyglTmW/I2IuPGxP1qbx2dePxcoqq2r29jIYGGSGRJdzJurzhI1W7IrmMoCt+yCUbTlcXtXfo1gmSWJpISrNhguYr3XDsSrHkbEedbAV7QsaTsJeLlKLVc/77mK2thZN7Kd0WRp0JYoZAAIAM27BGcZuzzAOvKqUOFnhgiZVKymSaAK3ZOSWQlGCg2svZaw4C9fQqry4NGdZGQF0uFYjVb8bHle1Y8Q0PGNJRa2+9Jr8mI2hsWRZXQK5H2YgZIw2VVVRYSE/ZEMGJ6351ovRzZoRppGS0jzSdojUpmuLHpzp4K9plBJ2TyeKnOGl/Pn3CiiojiEz5Mwz2zZb65b2vbpfSnOYlqlisFna97adKsJiULMgYFltmF9RfUXHK9jRFiFbNlYHKcrW5MOR8dRWptboxqyj7L+L+K99mfF/FXcPiUdcyMGU31BuNDY/yCKkvT+bLuZoQt9l/F/FHsv4v4q9LiUUqGYAucqgm2ZrFrDqbAn5GpL0eZMNCK2DwuS+t71ary9F6Ru3bNSo9oqLEYhEUu7BVGpJNgPM1IDWGntFeE1AmOjMe9DqY8ufPfs5bXzX6WoAmkW4I6il3sv4v4q7Li0VQ7MApsASdLsQF+pIA869mxKIVDMAXOVQT3msWsOpsCfkaaMpLgxpPko+zPi/ij2Z8X8UyvRet82XczQhd7M+L+K89l/F/FXocQjXysDlJU2PBhxB8dRUl63zJdw0I8jWwA6V1Xmai9TGPaKpYfa0EkjRJNG0i95AwJFtDcVdrWmuQCiiisAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArJbewZkxotLJHlwjm8bZSTvFtc9Adbc+da2uSop8c3B2jGfOo9rzMFMkrJG4wm+kBy5FeGRmIP4A0gQE6WvyrjZ+LAbKcU64V8RiC0+fKWdVj3amS3Agvr+LION9fo+6HCw+leblbWsLdLV0f9UeNPyueOTNJ8rw20JVihQT5ItzI6SPKYM8m/ku11jbOwAU7vQHNwPJpLiMQY55nxEgkhjw7BUJVM5RWclCL2b3W4dAa+gmIcLDTwr0xjpx4+NNLxabvQvjvt/BmkzXpbJllwDa9nEOdBc6YTEHQcz4Vmdl42ed91FiGvNhXdSZt6wlUoUZgFCxNqQUUkWJr6WV/iocRg1ZGQEpcEZk7LC/NTyPjU8fiFGKi49K+7/P0NaPn+J25iJolxKsY4ZpliOZzEI0SNsxL5SY8091zW4KouL1PsiaeebDRviX3ZGJa8TsQ6xyQhAZCilwMzDMBqOZ1rcYLAJFGsSCyKMoB108b8T41MIxppw4U8vEw4jDvX1S/kNJnfT7AJJg5GcXMYzKLmwa4s1uBI5X4Vo4+Fest9DXtczm3BR7X9a9jTl+Br5hssywYLClJpSJcDMzKTcKyRoyFBbsZbkacedzX1C1c7sdB04cqfDm8tNNXb/D9/oDR822ti8+YS4h1lXE4YRw3sGizwtmCW7YJzEvyItfS1dviy82GZp3bEjFy5oCdEyxzhOxbsi2Wzfizc6+jGIdB9KN0L3sL9bVZeLSVae/bqq7cdRdJ8rw+2sV6vJJvxvPVJnlQSs7JKEuDu92Bh2V7jLm+tr1sdhrJHiniM0kinDxyfaHNZyzqxBtoCANOAtpatHuhroNeOnHz617lFLl8RGaaUUvn7dDUj55jcdkkkjzsmfFTm+93CHKkWjS5SwPauFXjY9K4w218UMPhmzuzYuM4cHjknEhAktYWO7zkmw+7GlfRTEDxA434c+tVJdlI0yTEsTGDkW/YBNwXy8M1iRfoTTR8TCqcflP8ANf0DTMNLtLEjFMm+CsmJjjRGke7Q3QfcCM7wMpYmTNob6jKa0vodG5iaWSWSQu8gs7XCqsrqAo5aAa0/3Yvewv1516FA0qeTOpQ0qNcfQ1IxGw8dhcTiohA8SRYcyCGMMN5K5BV2y3uEAzEX1Y66WF9zUawKDcKAfACpKTLkU3tx/YJBRRRUjQooooAKKKKACiiigAooooA//9k=)

結合層では主に「nn.Linear：線型結合」「Conv2d：画像データの畳み込み計算」

※確率的勾配降下法は「微分から傾きを求めて損失関数が小さくなる方向に進むことで最適化を図る」という手法なので、微分計算が楽なlog(x)やe^xを含む交差エントロピー誤差は相性が良いのです。
※学習率とは、最適化の際にどのくらいパラメータを動かすかを決めるもので「0.01~0.03」あたりがよく使われます。

**学習**
"""

'''学習'''
for epoch in range(500):                   #100回繰り返す
  total_loss = 0                           #損失を格納する変数を0で初期化
  for train_x, train_y in train_loader:    #ミニバッチからデータを取り出す
    optimizer.zero_grad()                  #勾配をクリア
    loss = criterion( net(train_x), train_y )#予測値と正解値で損失(loss)を計算
    loss.backward()                        #誤差逆伝搬(各変数の勾配を計算)
    optimizer.step()                       #パラメータの更新
    total_loss += loss.data                #各エボック毎に損失の累計を計算

    if(epoch+1)%10 == 0:                   #10回に1回結果を表示
      print(epoch+1,":",total_loss)

"""今回はデータを100回学習させた。
1回の学習でtrain_loaderのミニバッチからデータを取り出し、予測値(net(train_x))と正解値(train_y)の損失を計算することで、最適なパラメータを探していきます。
学習がうまく進んでいるか確認したいので、50回に1回の頻度で結果を表示させました。
微小ではありますが少しずつ学習が進んでいる様子が観察できます。

**テスト**
"""

test_net = net(test_X).detach()    #test_Xから勾配を計算する演算情報を削除
print("test_X:", test_X[:1], "\n") #test_xの中身を表示(先頭1行目)
print("test_net:", test_net[:1])   #test_netの中身を表示(先頭1行目)

"""**精度計算**"""

'''精度を計算'''
result = torch.max(test_net, 1)[1] #行の数値を比較し、最大値を取る別のインデックスを返す
#numpyに変換し数値の一致率を計算
accuracy = sum(test_Y.data.numpy() == result.numpy()) / len(test_Y.data.numpy())
accuracy

"""**◆torch.max**

torch.maxは配列内のある方向で「最大値とそのインデックス」を取得することができます。

2つの特徴量を持つtest_netの配列で*torch.maxを用います。そしてデータ型をtensorからnumpyに変換し、「torch.maxで求めた値(result)」と「test_Yの値(test_Y.data)」の一致率を求め、それを正解率としました.
"""

print("正解率:",round(accuracy*100,1),"%")

